import { rateLimiter } from '../middleware/rateLimit';

interface SemanticSearchResult {
  id: string;
  text: string;
  similarity: number;
}

interface TafsirResponse {
  source: string;
  content: string;
  cached: boolean;
  generatedAt: Date;
}

interface AIProvider {
  name: string;
  priority: number;
  available: boolean;
  search: (query: string) => Promise<SemanticSearchResult[]>;
  generateTafsir: (surahId: number, verseNumber: number) => Promise<string>;
}

class ResilientAIService {
  private providers: AIProvider[] = [
    {
      name: 'zhipu-glm4',
      priority: 1,
      available: true,
      search: this.zhipuSemanticSearch.bind(this),
      generateTafsir: this.zhipuGenerateTafsir.bind(this)
    },
    // Fallback providers can be added here
  ];
  
  // --- Zhipu AI Implementation (Placeholder) ---
  private async zhipuSemanticSearch(query: string): Promise<SemanticSearchResult[]> {
    // Call Zhipu API here
    return []; 
  }

  private async zhipuGenerateTafsir(surahId: number, verseNumber: number): Promise<string> {
    // Call Zhipu API here
    return `Tafsir for ${surahId}:${verseNumber} (Generated by GLM-4)`;
  }
  // ---------------------------------------------

  async semanticSearch(query: string, userId: string): Promise<SemanticSearchResult[]> {
    // 1. Rate Limiting
    await rateLimiter.checkLimit(userId, 'semantic_search', {
      requests: 100,
      window: 15 * 60 * 1000, // 15 mins
      message: 'Search limit exceeded. Please try again later.'
    });
    
    // 2. Try providers in priority order
    for (const provider of this.providers) {
      if (!provider.available) continue;
      try {
        return await provider.search(query);
      } catch (error) {
        console.error(`Provider ${provider.name} failed:`, error);
        continue;
      }
    }
    
    throw new Error('All AI providers failed.');
  }
  
  async generateTafsir(
    surahId: number, 
    verseNumber: number, 
    userId: string
  ): Promise<TafsirResponse> {
    // 1. Rate Limiting
    await rateLimiter.checkLimit(userId, 'tafsir_generation', {
      requests: 50,
      window: 60 * 60 * 1000, // 1 hour
      message: 'Tafsir generation limit exceeded.'
    });

    // 2. Try providers
    for (const provider of this.providers) {
      if (!provider.available) continue;
      try {
        const content = await provider.generateTafsir(surahId, verseNumber);
        return {
          source: provider.name,
          content,
          cached: false,
          generatedAt: new Date()
        };
      } catch (error) {
        console.error(`Provider ${provider.name} failed:`, error);
        continue;
      }
    }
    
    throw new Error('Tafsir generation failed on all providers.');
  }
}

export const aiService = new ResilientAIService();
